{% load static %}
{% load compress %}

<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>Голодные игры</title>

    {% compress css %}

        <link rel="stylesheet" href="{% static 'scss/game.scss' %}" type="text/x-scss">

    {% endcompress %}

    <script src="{% static 'packages/jquery-3.6.1.min.js' %}"></script>

    <style>

        @font-face {

            font-family: RubikGlitchPop;
            src: url("{% static 'fonts/RubikGlitchPop.ttf' %}");
        
        }

        @font-face {

            font-family: PressStart;
            src: url("{% static 'fonts/PressStart.ttf' %}");

        }

        #gameCanvas {

            background-image: url("{% static 'jpg/galaxy.jpg' %}")

        }

    </style>

</head>

<body>

    <script>

        document.addEventListener('DOMContentLoaded', function() {
            var audio = document.getElementById('song');
            audio.play();
        });

    </script>

<!--     <audio  controls autoplay loop>
        <source src="{% static 'mp3/song.mp3' %}" type="audio/mpeg">
    </audio> -->

    <div class="topnav">

        <div class="logo"></div>

        <a href="/register/" target="_blank" class="auth-btn">

            <button id="registerBtn">

                Зарегистрироваться

            </button>

        </a>

    </div>
    
    <div id="startMenu">
        
        <h1>Голодные игры</h1>

        <button class="pulse" id="startButton">Играть</button>

        <div class="style-btns">

            <button id="changePlayerColor">Цвет игрока</button>
            <button id="changeBackground">Фон</button>

        </div>

    </div>

    <div id="playerColorMenu">

        <h1>Цвет игрока</h1>

        <div id="colorSelectorContainer"></div>

        <button id="savePlayerColor">Сохранить</button>

    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Menus -->
    <script>

        $('#changePlayerColor').click(function() {

            $('#startMenu').hide();

            $('#playerColorMenu').css('display', 'flex');

        });

        $('#savePlayerColor').click(function() {

            $('#playerColorMenu').hide();

            $('#startMenu').css('display', 'flex');

        });

        $('#startButton').click(function() {

            $('.topnav').hide();
            $('#startMenu').hide();


        });

    </script>

    <!-- Game -->
    <script>

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const startMenu = document.getElementById('startMenu');
        const colorSelectorContainer = document.getElementById('colorSelectorContainer');

        canvas.style.display = 'none'; // Hide canvas initially

        const player = {

            x: canvas.width / 2,
            y: canvas.height / 2,
            width: 20,
            height: 20,
            vxl: 0,
            vxr: 0,
            vyu: 0,
            vyd: 0,
            speed: 5,
            color: '#FFFFFF' // Default player color (white)
            
        };

        const defaultColors = ['#FFFFFF', '#FF0000', '#0000FF', '#00FF00', '#FFFF00'];

        // Create color selectors
        defaultColors.forEach(color => {

            const colorSelector = document.createElement('div');
            colorSelector.className = 'colorSelector';
            colorSelector.style.backgroundColor = color;

            if (color === player.color) {

                colorSelector.classList.add('selected');

            }

            colorSelector.addEventListener('click', () => selectColor(color, colorSelector)); // Pass colorSelector element
            colorSelectorContainer.appendChild(colorSelector);

        });

        function selectColor(color, colorSelector) {

            player.color = color;
            // Remove 'selected' class from all color selectors
            const colorSelectors = document.querySelectorAll('.colorSelector');
            colorSelectors.forEach(selector => selector.classList.remove('selected'));
            // Add 'selected' class to the clicked color selector
            colorSelector.classList.add('selected');

        }

        /* Arrow movement */

        addEventListener('keydown', function (e) {

            if (e.code == 'ArrowRight') player.vxr = player.speed;
            if (e.code == 'ArrowLeft') player.vxl = -player.speed;
            if (e.code == 'ArrowUp') player.vyu = -player.speed;
            if (e.code == 'ArrowDown') player.vyd = player.speed;

        });

        addEventListener('keyup', function (e) {

            if (e.code == 'ArrowRight') player.vxr = 0;
            if (e.code == 'ArrowLeft') player.vxl = 0;
            if (e.code == 'ArrowUp') player.vyu = 0;
            if (e.code == 'ArrowDown') player.vyd = 0;

        });

        let level = 1;

        /* Balloons */
        const totalBalloons = 10; // Static amount of balloons
        let balloons = [];
        let balloonsCollected = 0;

        /* Monsters */
        let monsters = [];
        let totalMonsters = 2; // Initial number of monsters
        let monsterSpeed = 2.5; // Monster speed
        
        let gameRunning = false;

        startButton.addEventListener('click', startGame);

        function startGame() {

            gameRunning = true;
            canvas.style.display = 'block';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            spawnBalloons();
            spawnMonsters();
            updateGame();

        }

        /* Draw a player (circle) */
        function drawPlayer() {

            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y + player.height / 2, player.width / 2, 0, Math.PI * 2);
            ctx.fillStyle = player.color;
            ctx.fill();
            ctx.strokeStyle = "black"; // Black border
            ctx.lineWidth = 2; // Border width
            ctx.stroke();
            ctx.closePath();

        }

        /* Make sure player can't go beyond canvas */
        function movePlayer() {

            if (player.x < 0) {

                player.x = 0;

            }

            if (player.x + player.width > canvas.width) {

                player.x = canvas.width - player.width;

            }

            if (player.y < 0) {

                player.y = 0;

            }

            if (player.y + player.height > canvas.height) {

                player.y = canvas.height - player.height;

            }
        
        }

        /* Draw balloons */
        function drawBalloons() {

            for (let i = 0; i < balloons.length; i++) {

                let balloon = balloons[i];

                img = new Image();
                img.src = "{% static 'svg/coin.svg' %}"

                if (!balloon.collected) {
                    ctx.drawImage(img, balloon.x, balloon.y, 40, 40);

                }

            }

        }

        /* Spawn balloons at random locations at the deges */
        function spawnBalloons() {

            balloons = [];
            const balloonRadius = 20; // Radius of the balloon
            const minDistance = balloonRadius * 2; // Minimum distance between balloon centers

            for (let i = 0; i < totalBalloons; i++) {

                let overlapping = true;
                let newX, newY;

                // Continue generating new positions until no overlap is found
                while (overlapping) {

                    overlapping = false; // Assume no overlap initially
                    newX = Math.random() * (canvas.width - balloonRadius * 2) + balloonRadius;
                    newY = Math.random() * (canvas.height - balloonRadius * 2) + balloonRadius;

                    // Check against existing balloons
                    for (let j = 0; j < balloons.length; j++) {

                        const otherBalloon = balloons[j];
                        const distance = Math.sqrt((newX - otherBalloon.x) ** 2 + (newY - otherBalloon.y) ** 2);

                        // If distance between centers is less than minimum required, it's overlapping
                        if (distance < minDistance) {

                            overlapping = true;
                            break;

                        }

                    }

                }

                // Add non-overlapping balloon to the array
                balloons.push({

                    x: newX,
                    y: newY,
                    radius: balloonRadius,
                    color: '#ffdf00', // Random color
                    collected: false
                });

            }

        }

        function spawnMonsters() {

            monsters = [];
            const padding = 40; // Padding to keep monsters away from the edges
            const minDistance = 60; // Minimum distance between monsters
            
            for (let i = 0; i < totalMonsters; i++) {

                let side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
                let x, y, speedX, speedY;

                switch (side) {

                    case 0: // top edge
                        x = Math.random() * (canvas.width - padding * 2) + padding;
                        y = padding;
                        break;

                    case 1: // right edge
                        x = canvas.width - padding;
                        y = Math.random() * (canvas.height - padding * 2) + padding;
                        break;

                    case 2: // bottom edge
                        x = Math.random() * (canvas.width - padding * 2) + padding;
                        y = canvas.height - padding;
                        break;

                    case 3: // left edge
                        x = padding;
                        y = Math.random() * (canvas.height - padding * 2) + padding;
                        break;
                }

                speedX = monsterSpeed;
                speedY = monsterSpeed;

                /* Randomize travel direction of monsters */
                if (Math.random() < 0.5) speedX *= -1;
                if (Math.random() < 0.5) speedY *= -1;

                // Check if the newly spawned monster overlaps with existing ones
                let overlapping = false;
                for (let j = 0; j < monsters.length; j++) {

                    let otherMonster = monsters[j];
                    if (Math.abs(x - otherMonster.x) < minDistance && Math.abs(y - otherMonster.y) < minDistance) {
                        
                        overlapping = true;
                        break;

                    }

                }

                if (!overlapping) {

                    monsters.push({

                        x: x,
                        y: y,
                        width: 40,
                        height: 40,
                        speedX: speedX,
                        speedY: speedY

                    });

                } else {
                    // If overlapping, try again
                    i--;
                }

            }

        }

        /* Draw monsters (images) */
        function drawMonsters() {

            const monsterImage = new Image();
            monsterImage.src = "{% static 'svg/monster.svg' %}"; // Path to the monster image

            for (let monster of monsters) {
                ctx.drawImage(monsterImage, monster.x, monster.y, monster.width, monster.height);
            }
            
        }

        function drawScore() {

            ctx.font = "16px PressStart";
            ctx.fillStyle = "#FFF";
            ctx.fillText("Уровень: " + level, 20, 40);

        }

        /* Monster movement */
        function moveMonsters() {

            for (let i = 0; i < monsters.length; i++) {

                let monster = monsters[i];
                monster.x += monster.speedX;
                monster.y += monster.speedY;

                // Reverse direction if hitting canvas edges
                if (monster.x < 0 || monster.x + monster.width > canvas.width) {
                    
                    monster.speedX *= -1;
                
                }

                if (monster.y < 0 || monster.y + monster.height > canvas.height) {
                    
                    monster.speedY *= -1;
                
                }

                // Check collision with other monsters
                for (let j = 0; j < monsters.length; j++) {

                    if (i !== j) {

                        let otherMonster = monsters[j];

                        if (monster.x < otherMonster.x + otherMonster.width &&
                            
                            monster.x + monster.width > otherMonster.x &&
                            monster.y < otherMonster.y + otherMonster.height &&
                            monster.y + monster.height > otherMonster.y) {
                            // Bounce off each other
                            let tempSpeedX = monster.speedX;
                            let tempSpeedY = monster.speedY;
                            monster.speedX = otherMonster.speedX;
                            monster.speedY = otherMonster.speedY;
                            otherMonster.speedX = tempSpeedX;
                            otherMonster.speedY = tempSpeedY;

                        }

                    }

                }

            }

        }

        function checkCollision() {

            for (let balloon of balloons) {

                if (!balloon.collected && player.x < balloon.x + balloon.radius &&
                    
                    player.x + player.width > balloon.x - balloon.radius &&
                    player.y < balloon.y + balloon.radius &&
                    player.y + player.height > balloon.y - balloon.radius) {
                    balloon.collected = true;
                    balloonsCollected++;

                    /* New level if all balloons collected */
                    if (balloonsCollected === totalBalloons) {
                        
                        level++;
                        balloonsCollected = 0;
                        totalMonsters += 2;

                        /* Respawn player at the center */
                        player.x = canvas.width / 2;
                        player.y = canvas.height / 2;

                        spawnBalloons();
                        spawnMonsters();

                    }

                }

            }

        }

        function checkMonsterCollision() {

            for (let monster of monsters) {

                if (player.x < monster.x + monster.width &&
                    player.x + player.width > monster.x &&
                    player.y < monster.y + monster.height &&
                    player.y + player.height > monster.y) {
                    level = 1;
                    balloonsCollected = 0;
                    totalMonsters = 2;
                    monsterSpeedMin = 1;
                    monsterSpeedMax = 4;
                    player.x = canvas.width / 2; // Respawn player at the center
                    player.y = canvas.height / 2;
                    spawnBalloons();
                    spawnMonsters();
                    break;

                }

            }

        }

        function updateGame() {

            if (!gameRunning) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height); // clear entire canvas
            player.x += player.vxl;
            player.x += player.vxr;
            player.y += player.vyu;
            player.y += player.vyd;

            drawPlayer();
            movePlayer();

            drawBalloons();

            drawMonsters();
            moveMonsters();

            drawScore();

            checkCollision();

            checkMonsterCollision();

            requestAnimationFrame(updateGame);

        }

    </script>

</body>

</html>
